
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import subprocess
import threading
import queue
import os

class AudioConverterApp:
    def __init__(self, root):
        self.root = root
        self.root.title("ffmpeg Audio Converter")
        self.root.geometry("700x550")

        self.input_files = []
        self.output_dir = ""
        self.output_format = tk.StringVar(value="mp3")
        self.queue = queue.Queue()

        # --- Main Frame ---
        main_frame = ttk.Frame(root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- Input Selection ---
        input_frame = ttk.Frame(main_frame)
        input_frame.pack(fill=tk.X, pady=5)

        self.select_files_btn = ttk.Button(input_frame, text="1. Select Audio Files", command=self.select_files)
        self.select_files_btn.pack(side=tk.LEFT, padx=(0, 10))

        self.files_listbox = tk.Listbox(main_frame, height=8, selectmode=tk.EXTENDED)
        self.files_listbox.pack(fill=tk.X, pady=5)

        # --- Output Selection ---
        output_frame = ttk.Frame(main_frame)
        output_frame.pack(fill=tk.X, pady=10)

        self.select_dir_btn = ttk.Button(output_frame, text="2. Select Output Directory", command=self.select_output_dir)
        self.select_dir_btn.pack(side=tk.LEFT, padx=(0, 10))

        self.output_dir_label = ttk.Label(output_frame, text="No directory selected...")
        self.output_dir_label.pack(side=tk.LEFT)

        # --- Format and Conversion ---
        convert_frame = ttk.Frame(main_frame)
        convert_frame.pack(fill=tk.X, pady=10)

        format_label = ttk.Label(convert_frame, text="3. Choose Output Format:")
        format_label.pack(side=tk.LEFT, padx=(0, 10))

        self.format_menu = ttk.Combobox(convert_frame, textvariable=self.output_format, state="readonly",
                                      values=["mp3", "wav", "ogg", "flac", "m4a", "aac"])
        self.format_menu.pack(side=tk.LEFT, padx=(0, 20))

        self.convert_btn = ttk.Button(convert_frame, text="4. Convert", command=self.start_conversion_thread)
        self.convert_btn.pack(side=tk.LEFT)

        # --- Status/Log Area ---
        log_label = ttk.Label(main_frame, text="Conversion Log:")
        log_label.pack(fill=tk.X, pady=(10, 0))

        self.log_area = tk.Text(main_frame, height=10, state=tk.DISABLED, wrap=tk.WORD)
        self.log_area.pack(fill=tk.BOTH, expand=True)

        # Periodically check the queue for messages from the worker thread
        self.root.after(100, self.process_queue)

    def select_files(self):
        files = filedialog.askopenfilenames(
            title="Select Audio Files",
            filetypes=(("All Supported", "*.m4a *.mp3 *.wav *.ogg *.flac *.aac *.avi *.mp4 *.mkv"),
                       ("All files", "*.*"))
        )
        if files:
            self.input_files.extend(files)
            self.update_files_listbox()

    def update_files_listbox(self):
        self.files_listbox.delete(0, tk.END)
        for f in self.input_files:
            self.files_listbox.insert(tk.END, os.path.basename(f))

    def select_output_dir(self):
        directory = filedialog.askdirectory(title="Select Output Directory")
        if directory:
            self.output_dir = directory
            self.output_dir_label.config(text=self.output_dir)

    def log(self, message):
        self.log_area.config(state=tk.NORMAL)
        self.log_area.insert(tk.END, message + "\n")
        self.log_area.see(tk.END)
        self.log_area.config(state=tk.DISABLED)

    def start_conversion_thread(self):
        if not self.input_files:
            messagebox.showerror("Error", "No input files selected.")
            return
        if not self.output_dir:
            messagebox.showerror("Error", "No output directory selected.")
            return

        # Disable buttons during conversion
        self.convert_btn.config(state=tk.DISABLED)
        self.select_files_btn.config(state=tk.DISABLED)
        self.select_dir_btn.config(state=tk.DISABLED)

        self.log("--- Starting Conversion ---")
        
        # Create and start the worker thread
        thread = threading.Thread(target=self.convert_files, daemon=True)
        thread.start()

    def convert_files(self):
        try:
            for i, input_file in enumerate(self.input_files):
                base_name = os.path.basename(input_file)
                file_name_no_ext = os.path.splitext(base_name)[0]
                output_format = self.output_format.get()
                output_file = os.path.join(self.output_dir, f"{file_name_no_ext}.{output_format}")

                self.queue.put(f"({i+1}/{len(self.input_files)}) Converting '{base_name}'...")

                # The -y flag overwrites the output file if it exists.
                command = [
                    'ffmpeg',
                    '-i', input_file,
                    '-y', # Overwrite output file
                    '-vn', # No video
                    '-c:a', 'libmp3lame' if output_format == 'mp3' else 'pcm_s16le' if output_format == 'wav' else 'libvorbis' if output_format == 'ogg' else 'flac', # Codec
                    output_file
                ]
                
                # Use CREATE_NO_WINDOW flag on Windows to prevent cmd pop-up
                startupinfo = None
                if os.name == 'nt':
                    startupinfo = subprocess.STARTUPINFO()
                    startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, startupinfo=startupinfo)
                
                # We can read stderr to get progress info from ffmpeg
                while True:
                    line = process.stderr.readline()
                    if not line:
                        break
                    # You could parse this line for progress, but for simplicity we just log it
                
                process.wait()

                if process.returncode == 0:
                    self.queue.put(f"Successfully converted to '{os.path.basename(output_file)}'")
                else:
                    error_output = process.stderr.read()
                    self.queue.put(f"ERROR converting '{base_name}': {error_output}")

            self.queue.put("--- Conversion Complete ---")
        except Exception as e:
            self.queue.put(f"An unexpected error occurred: {e}")
        finally:
            # Signal that the process is done
            self.queue.put("DONE")

    def process_queue(self):
        try:
            while True:
                message = self.queue.get_nowait()
                if message == "DONE":
                    # Re-enable buttons
                    self.convert_btn.config(state=tk.NORMAL)
                    self.select_files_btn.config(state=tk.NORMAL)
                    self.select_dir_btn.config(state=tk.NORMAL)
                    # Clear input files for next batch
                    self.input_files = []
                    self.update_files_listbox()
                else:
                    self.log(message)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.process_queue)


if __name__ == "__main__":
    # Check for ffmpeg
    try:
        subprocess.run(['ffmpeg', '-version'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except (subprocess.CalledProcessError, FileNotFoundError):
        messagebox.showerror("ffmpeg Not Found", 
                             "ffmpeg is not installed or not in your system's PATH.\n"
                             "Please install ffmpeg to use this application.")
        exit()

    root = tk.Tk()
    app = AudioConverterApp(root)
    root.mainloop()
